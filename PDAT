#include <IntervalTimer.h>
#include <Math.h>

IntervalTimer myTimer;

volatile uint32_t send_cnt = 0;
volatile uint32_t check_cnt = 0;
bool toggle = false;

const int RX_BUFFER_SIZE = 100;
char rxData[RX_BUFFER_SIZE];
int rxIndex = 0;
char Send_Data[256]; // 크기를 증가시켜 더 많은 데이터를 저장할 수 있도록 함
bool comCheck = false;

// K-LD7 COMMAND
char cmd01[] = {0x49, 0x4E, 0x49, 0x54, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}; // INIT
char cmd02[] = {0x47, 0x4E, 0x46, 0x44, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00}; // GNFD + PDAT
char cmd03[] = {0x47, 0x42, 0x59, 0x45, 0x00, 0x00, 0x00, 0x00}; // GBYE

void processPDATData(const char* data, int length) {
    const int TARGET_DATA_SIZE = 8;
    char buffer[64]; // 임시 버퍼

    // 문자열 초기화
    strcpy(Send_Data, "[");

    for (int i = 0; i < length; i += TARGET_DATA_SIZE) {
        // 데이터 추출
        uint16_t distance = data[i] | (data[i + 1] << 8);
        int16_t speed = data[i + 2] | (data[i + 3] << 8);
        int16_t angle = data[i + 4] | (data[i + 5] << 8);
        uint16_t magnitude = data[i + 6] | (data[i + 7] << 8);
        
        float angle_radians = static_cast<float>(angle) / 100.0 ;
        float longitudinal_distance = (distance / 100.0) * cos(angle_radians); // 종거리
        float lateral_distance = (distance / 100.0) * sin(angle_radians); // 횡거리
        float longitudinal_speed = (static_cast<float>(speed) / 100.0 / 3.6) * cos(angle_radians);
        float lateral_speed = (static_cast<float>(speed) / 100.0 / 3.6) * sin(angle_radians);
        float L_magnitude = magnitude * cos(angle_radians);
        float W_magnitude = magnitude * sin(angle_radians);

        // 문자열로 포맷팅
        sprintf(buffer, "[%.4f,%.4f,%.4f,%.4f,%.4f],",
                static_cast<float>(speed) / 100.0 / 3.6, 
                longitudinal_distance,
                lateral_distance,
                longitudinal_speed,
                lateral_speed);

        // Send_Data에 추가
        strcat(Send_Data, buffer);
    }

    // 마지막 콤마를 제거하고 배열을 닫음
    int len = strlen(Send_Data);
    Send_Data[len - 1] = ']';
    Send_Data[len] = '\0';
}

void setup() {
    pinMode(LED_BUILTIN, OUTPUT);
    Serial.begin(115200);
    Serial1.begin(115200, SERIAL_8E1);
    delay(100);
    myTimer.begin(TimerHandler, 100); // Interval in microseconds
}

void loop() {
    if (send_cnt > 1000) {
        send_cnt = 0;
        check_cnt = 1000;

        digitalWrite(LED_BUILTIN, toggle);
        toggle ^= true;

        Serial1.write(cmd02, sizeof(cmd02)); // GNFD + PDAT 명령 전송
    }

    if (check_cnt > 1300) {
        check_cnt = 0;

        while (Serial1.available()) {
            char rxChar = (char)Serial1.read();
            rxData[rxIndex++] = rxChar;
            if (rxIndex >= RX_BUFFER_SIZE - 1) {
                rxIndex = RX_BUFFER_SIZE - 1;  // Prevent buffer overflow
                break;
            }
            comCheck = true;
        }
    }

    if (comCheck) {
        // Pass the received data and its length to processPDATData()
        processPDATData(rxData, rxIndex);  // Corrected function call

        // Print the Send_Data if needed
        Serial.println(Send_Data); 

        memset(rxData, 0, RX_BUFFER_SIZE);  // Clear the buffer for new data
        rxIndex = 0;  // Reset index
        comCheck = false;
    }
}

void TimerHandler() {
    if (send_cnt < 10000) send_cnt++;
    if (check_cnt < 10000) check_cnt++;
}
